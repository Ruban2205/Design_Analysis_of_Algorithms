# üëã Design and Analysis of Angorithm

Welcome to the **Design and Analysis of Algorithms** repository! This Collection of algorithms aims to assist students and developers in understanding and implementing various fundamental algorithms commonly encountered in computer science and programming. 

This repository serves as a valuable resource for individuals interested in exploring the design and analysis of algorithms. Whether you are a student studying computer science or a developer seeking to enhance your algorithmic skills, this collection will provide you with a diverse set of algorithms to learn from and apply in your projects.

Each algorithm has been thoughtfully implemented and documented, following best practices and adhering to established programming conventions. The code is written in a clear and understandable manner, with comprehensive comments to aid in comprehension and usage.


## üß© Algorithms Included 

This repository currently contains the following algorithms:

1) [Knapsack Problem](/01_KnapSack_problem.py):
The knapsack problem involves selecting a combination of items with specific values and weights to maximize the total value while respecting a weight constraint. It is a classic optimization problem often encountered in resource allocation scenarios.

2) [Job Sequencing Problem](02_Job_Sequencing.py):
The job sequencing problem focuses on scheduling a set of jobs with associated deadlines and profits to maximize the total profit. The objective is to assign jobs in such a way that their deadlines are met and the overall profit is optimized.

3) [0-1 Knapsack Problem](03_0~1-Knapsack_problem.py):
The 0-1 knapsack problem is a variation of the knapsack problem where items cannot be divided. Each item can either be included in the knapsack or excluded, and the goal is to find the combination that maximizes the total value while not exceeding the weight constraint.
 
4) [Longest Common Subsequence problem](04_Longest_Common_Subsequence.py):
The longest common subsequence problem involves finding the longest subsequence that appears in two or more sequences. A subsequence is a sequence of elements that appear in the same relative order but may not be contiguous. This problem has applications in areas like genetics, data comparison, and text analysis. 
 
5) [Travelling Salesman Problem](05_Travelling_Salesman.py):
The travelling salesman problem is an optimization problem where the objective is to find the shortest possible route that visits a given set of cities and returns to the starting city, visiting each city exactly once. It is a well-known NP-hard problem with numerous practical applications, including logistics, transportation, and network optimization.

6) [Dijkstra's Shortest Path Algorithm](06_Dijstra_shortest_path.py):
Dijkstra's algorithm is a popular algorithm used to find the shortest path between nodes in a graph with non-negative edge weights. It calculates the shortest path from a single source node to all other nodes in the graph, providing the minimum distance and the corresponding path for each destination node.

7) [Prim's Minimum Spanning Tree Problem](07_Prims_Minimum_Spanning_Tree.py):
Prim's algorithm is an efficient algorithm used to find the minimum spanning tree of a connected weighted graph. It starts with a single vertex and gradually adds the minimum weight edges that connect the existing tree to a new vertex until all vertices are included. The resulting tree has the minimum total weight among all possible spanning trees.

8) [Floyd's Algorithm](08_Floyd's_algorithm.py):
Floyd's algorithm, also known as the Floyd-Warshall algorithm, is used to find the shortest paths between all pairs of vertices in a weighted directed graph. It efficiently handles both positive and negative edge weights, allowing for the identification of the shortest distances and paths between all pairs of nodes.

9) [N-Queens Problem](09_n_queens_problem.py):
The N-Queens problem involves placing N queens on an N√óN chessboard in such a way that no two queens threaten each other. It is a classic puzzle that tests problem-solving skills and is often used to illustrate backtracking algorithms.

10) [Kruskal's Minimum Spanning Tree Algorithm](10_Kruskal_MST.py):
Kruskal's algorithm is a popular algorithm used to find the minimum spanning tree of a connected weighted graph. It operates by sorting the edges based on their weights and gradually adding the edges with the minimum weight while avoiding cycles. The resulting tree has the minimum total weight among all possible spanning trees.

Each algorithm is carefully crafted to solve specific problems or address common challenges encountered in programming and computer science. The implementations are thoroughly tested and optimized for efficiency.


## üöÄ Usage

To utilize these algorithms, follow these steps:

1. Clone the repository using the following command:
```
git clone https://github.com/Ruban2205/Design_Analysis_of_Algorithms.git
```

2. Navigate to the desired algorithm's directory:
```
cd Design_Analysis_of_Algorithms/AlgorithmX
```

3. Review the provided documentation and study the source code to gain a comprehensive understanding of the algorithm.
4. Implement or adapt the algorithm into your own projects, making any necessary modifications to suit your specific requirements.

## ü§ù Contributing

Contributions to this repository are greatly appreciated. If you would like to contribute, please follow these guidelines:

1) Fork the repository.

2) Create a new branch for your contribution.

3) Make your changes, ensuring adherence to the established coding style and documentation conventions.

4) Test your changes to ensure they do not introduce any regressions or issues.

5) Commit and push your changes to your forked repository.

6) Submit a pull request, clearly describing the purpose and scope of your contribution.

7) Your contribution will be reviewed, and any necessary feedback will be provided.

By contributing to this repository, you help foster a collaborative and educational environment for individuals seeking to improve their algorithmic knowledge.

## üìù License 

This repository is licensed under the [MIT LICENCE](/LICENCE). You are free to use, modify, and distribute the code included here for personal and commercial purposes. However, please ensure that you provide appropriate attribution to the original authors and retain


<hr/>

## Contact

[![Website](https://img.shields.io/badge/website-000000?style=for-the-badge&logo=About.me&logoColor=white)](https://rubangino.in/)
[![Mail](https://img.shields.io/badge/Gmail-D14836?style=for-the-badge&logo=gmail&logoColor=white)](mailto:info@rubangino.in)

<hr/>

### Star ‚≠ê this repository for Future use :)

Click below to gift a book to me.

[![BuyMeABook](https://img.shields.io/badge/Buy%20Me%20a%20Book-ffdd00?style=for-the-badge&logo=buy-me-a-book&logoColor=black)
](https://bit.ly/3M5jxLd)

**Thank You!!**

<hr/> 
